

```python
import pandas as pd
import numpy as np
```

# 一、索引器

## 1.表的索引

列索引是最常见的索引形式，一般通过[]来实现。通过[列名]可以从DataFrame中取出相应的列，返回值为Series


```python
df = pd.read_csv(r'./data/learn_pandas.csv', usecols=['School','Grade','Name','Gender','Weight','Transfer'])

df['Name'].head()
```




    0      Gaopeng Yang
    1    Changqiang You
    2           Mei Sun
    3      Xiaojuan Sun
    4       Gaojuan You
    Name: Name, dtype: object



若需取多个列，则使用[列名组成的列表]，其返回值为一个DataFrame


```python
df[['Name','Gender']].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Gaopeng Yang</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Changqiang You</td>
      <td>Male</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Mei Sun</td>
      <td>Male</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Gaojuan You</td>
      <td>Male</td>
    </tr>
  </tbody>
</table>
</div>



**另外**，若要取单列，且列名不包含空格，可用`.列名`取出，和[列名]等价


```python
df.Name.head()
```




    0      Gaopeng Yang
    1    Changqiang You
    2           Mei Sun
    3      Xiaojuan Sun
    4       Gaojuan You
    Name: Name, dtype: object



## 2. 序列的行索引

**【a】以字符串为索引的 Series**

如果取出单个索引的对应元素，则可以使用 `[item]` ，若 `Series` 只有单个值对应，则返回这个标量值，如果有多个值对应，则返回一个 `Series`：


```python
s = pd.Series(np.arange(1,7), index=['a','b','a','a','a','c'])
s
```




    a    1
    b    2
    a    3
    a    4
    a    5
    c    6
    dtype: int32




```python
s['a']
```




    a    1
    a    3
    a    4
    a    5
    dtype: int32




```python
s['c']
```




    6



如果要取出多个索引对应的元素，可用[item组成的列表]


```python
s[['b','c']]
```




    b    2
    c    6
    dtype: int32



如果想要取出某两个索引之间的元素，并且这两个索引是在整个索引中唯一出现，则可以使用切片，同时需要注意这里的切片会包含两个端点：


```python
s['c':'b':-2]
```




    c    6
    a    4
    b    2
    dtype: int32



**【b】以整数为索引的 Series**

在使用数据的读入函数时，如果不特别指定所对应的列作为索引，那么会生成从0开始的整数索引作为默认索引。当然，任意一组符合长度要求的整数都可以作为索引。


```python
s = pd.Series(['a','b','c','d','e','f'], index=[1,3,2,1,5,4])
s[1]
```




    1    a
    1    d
    dtype: object




```python
s[[1,5]]
```




    1    a
    1    d
    5    e
    dtype: object



如果使用整数切片，则会取出**对应索引位置的值**，注意这里的整数切片**同 Python 中的切片一样不包含右端点**：


```python
s[::2]
```




    1    a
    2    c
    5    e
    dtype: object




```python
s[-1:0:-2]
```




    4    f
    1    d
    3    b
    dtype: object




```python
s[1:-1]
```




    3    b
    2    c
    1    d
    5    e
    dtype: object



### 关于索引类型的说明

如果不想陷入麻烦，那么请不要把纯浮点以及任何混合类型（字符串、整数、浮点类型等的混合）作为索引，否则可能会在具体的操作时报错或者返回非预期的结果，并且在实际的数据分析中也不存在这样做的动机。


## 3. <font color=#FF7F50>loc索引器</FONT>

` DataFrame `行的选取,对于表而言，有两种索引器，一种是基于 元素 的 loc 索引器，另一种是基于 位置 的 iloc 索引器。

`loc`索引器的一般形式是 `loc[*, *]`，其中第一个 * 代表行的选择，第二个 * 代表列的选择，如果省略第二个位置写作`loc[*]`，这个 * 是指行的筛选。其中， * 的位置一共有五类合法对象，分别是：单个元素、元素列表、元素切片、布尔列表以及函数，下面将依次说明。

先利用 set_index 方法把 Name 列设为索引


```python
df_demo = df.set_index('Name')
```


```python
df_demo.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



**【a】 * 为单个元素**

此时，直接取出相应的行或列，如果该元素在索引中重复则结果为 DataFrame，否则为 Series ：


```python
df_demo.loc['Qiang Sun'] #元素在索引中重复，返回DataFrame
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>53.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>40.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_demo.loc['Quan Zhao']  #返回Series
```




    School      Shanghai Jiao Tong University
    Grade                              Junior
    Gender                             Female
    Weight                                 53
    Transfer                                N
    Name: Quan Zhao, dtype: object



也可以同时选择行和列：


```python
df_demo.loc['Qiang Sun','School'] #返回Series
```




    Name
    Qiang Sun              Tsinghua University
    Qiang Sun              Tsinghua University
    Qiang Sun    Shanghai Jiao Tong University
    Name: School, dtype: object




```python
df_demo.loc['Quan Zhao','School'] #返回单个元素
```




    'Shanghai Jiao Tong University'



**【b】 * 为元素列表**

此时，取出列表中所有元素值对应的行或列：


```python
df_demo.loc[['Qiang Sun','Quan Zhao'],['Gender','School']]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Gender</th>
      <th>School</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Sun</th>
      <td>Female</td>
      <td>Tsinghua University</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Female</td>
      <td>Tsinghua University</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Female</td>
      <td>Shanghai Jiao Tong University</td>
    </tr>
    <tr>
      <th>Quan Zhao</th>
      <td>Female</td>
      <td>Shanghai Jiao Tong University</td>
    </tr>
  </tbody>
</table>
</div>



**【c】 * 为切片**

之前的 Series 使用字符串索引时提到，如果是唯一值的起点和终点字符，那么就可以使用切片，并且包含两个端点，如果不唯一则报错：


```python
df_demo.loc['Gaojuan You':'Gaoqiang Qian', 'School':'Gender']
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Gaoqiang Qian</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
    </tr>
  </tbody>
</table>
</div>



需要注意的是，如果 DataFrame 使用整数索引，其使用整数切片的时候和上面字符串索引的要求一致，都是 <font color=#FF4500>元素 切片，包含端点且起点、终点不允许有重复值</font> 。


```python
df_loc_slice_demo = df_demo.copy()
df_loc_slice_demo.index = range(df_demo.shape[0],0,-1)
df_loc_slice_demo.loc[7:2]

```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>7</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>79.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Peking University</td>
      <td>Senior</td>
      <td>Female</td>
      <td>49.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Fudan University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Female</td>
      <td>45.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_loc_slice_demo.loc[3:5] # 没有返回，说明不是整数位置切片
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>



**【d】 * 为布尔列表**

在实际的数据处理中，根据条件来筛选行是极其常见的，此处传入 loc 的布尔列表与 DataFrame 长度相同，且<font color=#FF4100>列表为 True 的位置所对应的行会被选中， False 则会被剔除</font>。

例如，选出体重超过70kg的学生：


```python
df_demo.loc[df_demo.loc[:,'Weight']>70].head()
#df_demo.loc[df_demo.Weight>70].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaopeng Zhou</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaofeng Sun</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Zheng</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



前面所提到的传入元素列表，也可以通过 <font color=#FF4100>isin</font> 方法返回的布尔列表等价写出，例如选出所有大一和大四的同学信息：


```python
df_demo.loc[df_demo.Grade.isin(['Freshman','Senior'])].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



对于复合条件而言，可以用<font color=#FF5100> |（或）, &（且）, ~（取反） </font>的组合来实现，例如选出复旦大学中体重超过70kg的大四学生，或者北大男生中体重超过80kg的非大四的学生：


```python
condition_1_1 = df_demo.School == 'Fudan University'
condition_1_2 = df_demo.Grade == 'Senior'
condition_1_3 = df_demo.Weight > 70
condition_1 = condition_1_1 & condition_1_2 & condition_1_3  #复旦大学中体重超过70kg的大四学生
condition_2_1 = df_demo.School == 'Peking University'
condition_2_2 = df_demo.Grade == 'Senior'
condition_2_3 = df_demo.Weight > 80
condition_2 = condition_2_1 & (~condition_2_2) & condition_2_3

df_demo.loc[condition_1 | condition_2]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Han</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Zhou</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changpeng Zhao</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Qian</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



**练一练**

`select_dtypes` 是一个实用函数，它能够从表中选出相应类型的列，若要选出所有数值型的列，只需使用 `.select_dtypes('number')` ，请利用布尔列表选择的方法结合 `DataFrame` 的 `dtypes` 属性在 `learn_pandas` 数据集上实现这个功能。


```python
df_demo.dtypes
```




    School       object
    Grade        object
    Gender       object
    Weight      float64
    Transfer     object
    dtype: object




```python
df_demo.loc[:,df_demo.dtypes == 'float'].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Weight</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>46.0</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>70.0</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>89.0</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>41.0</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>74.0</td>
    </tr>
  </tbody>
</table>
</div>



直接用number不行，dtypes只能和数据类型等价，后面看下其他同学的思路

**【e】 * 为函数**

这里的函数，必须以前面的四种合法形式之一为返回值，并且函数的输入值为 `DataFrame` 本身。假设仍然是上述复合条件筛选的例子，可以把逻辑写入一个函数中再返回，需要注意的是函数的形式参数 `x` 本质上即为 `df_demo` ：


```python
def condition(x):
    condition_1_1 = x.School == 'Fudan University'
    condition_1_2 = x.Grade == 'Senior'
    condition_1_3 = x.Weight > 70
    condition_1 = condition_1_1 & condition_1_2 & condition_1_3
    condition_2_1 = x.School == 'Peking University'
    condition_2_2 = x.Grade == 'Senior'
    condition_2_3 = x.Weight > 80
    condition_2 = condition_2_1 & (~condition_2_2) & condition_2_3
    result = condition_1 | condition_2
    return result

df_demo.loc[condition]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Han</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Zhou</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changpeng Zhao</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Qian</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



此外，还支持使用 `lambda` 表达式，其返回值也同样必须是先前提到的四种形式之一：


```python
df_demo.loc[lambda x:'Qiang Sun', lambda x:'Gender']
```




    Name
    Qiang Sun    Female
    Qiang Sun    Female
    Qiang Sun    Female
    Name: Gender, dtype: object



由于函数无法返回如 <font color=FF4000>start: end: step</font> 的切片形式，故返回切片时要用 <font color=FF4000> slice </font>对象进行包装：


```python
df_demo.loc[lambda x: slice('Gaojuan You', 'Gaoqiang Qian')]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaoqiang Qian</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



<font color=FF4000> slice </font>对象参数为：
   > slice(start, end, step)


```python
df_demo.loc[lambda x: slice('Gaoqiang Qian', 'Gaojuan You', -1)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaoqiang Qian</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



最后需要指出的是，对于 Series 也可以使用 loc 索引，其遵循的原则与 DataFrame 中用于行筛选的 loc[*] 完全一致，此处不再赘述。

### <font color=red>不要使用链式赋值</font>

在对表或者序列赋值时，应当在使用一层索引器后直接进行赋值操作，这样做是由于进行多次索引后赋值是赋在临时返回的 copy 副本上的，而没有真正修改元素从而报出 SettingWithCopyWarning 警告。例如，下面给出的例子：


```python
df_chain = pd.DataFrame([[0,0],[1,0],[-1,0]], columns=list('AB'))
df_chain
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




```python
import warnings
with warnings.catch_warnings():
    warnings.filterwarnings('error')
    try:
        df_chain[df_chain.A!=0].B = 1 # 使用方括号列索引后，再使用点的列索引
    except Warning as w:
        Warning_Msg = w
        
print(Warning_Msg)
```

    
    A value is trying to be set on a copy of a slice from a DataFrame.
    Try using .loc[row_indexer,col_indexer] = value instead
    
    See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy
    


```python
df_chain.loc[df_chain.A!=0,'B'] = 1

df_chain
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



## 4. iloc索引器

`iloc` 的使用与 loc 完全类似，只不过是针对位置进行筛选`iloc[*, *]`，在相应的` * `位置处一共也有五类合法对象，分别是：**整数、整数列表、整数切片、布尔列表以及函数**，函数的返回值必须是前面的四类合法对象中的一个，其输入同样也为 DataFrame 本身。<font color=red>切片不包含结束端点</font>


```python
df_demo.iloc[1, 1] # 第二行第二列
```




    'Freshman'




```python
df_demo.iloc[[0, 1], [0, 1]] # 前两行前两列
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_demo.iloc[1: 4, 2:4] # 切片不包含结束端点
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Gender</th>
      <th>Weight</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Changqiang You</th>
      <td>Male</td>
      <td>70.0</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Male</td>
      <td>89.0</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Female</td>
      <td>41.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_demo.iloc[lambda x: slice(1, 4)] # 传入切片为返回值的函数
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



在使用布尔列表的时候要特别注意，不能传入 Series 而必须传入序列的 values ，否则会报错。因此，在使用布尔筛选的时候还是应当优先考虑 loc 的方式。

选出体重超过在70到80之间的学生： 
>可用Series.between, 或者后续的query()方法


```python
df_demo.iloc[(df_demo.Weight.between(70, 80)).values].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaopeng Zhou</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaofeng Sun</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaoli Zhao</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>78.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_demo.School.iloc[1]
```




    'Peking University'




```python
df_demo.School.iloc[1:5:2]
```




    Name
    Changqiang You    Peking University
    Xiaojuan Sun       Fudan University
    Name: School, dtype: object



## 5. query方法

执行结果返回**布尔列表**  
输入查询的字符串内容跨行，需单独用''


```python
df.query('((School == "Fudan University")&'
         ' (Grade == "Senior")&'
         ' (Weight > 70))|'
         '((School == "Peking University")&'
         ' (Grade != "Senior")&'
         ' (Weight > 80))')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>38</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Qiang Han</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>66</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>99</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Changpeng Zhao</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>131</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Qian</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>




```python
#df.query('(School == "Fudan University" & Grade == "Senior")')
df.query('(School == "Fudan University" &'
          'Grade == "Senior")')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>39</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>46</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Feng Zhou</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>49</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Gaomei Lv</td>
      <td>Female</td>
      <td>34.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>52</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chunli Lv</td>
      <td>Female</td>
      <td>56.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>66</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>77</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Gaopeng Qin</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>112</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chunjuan Xu</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>129</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Juan Zhang</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>131</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Qian</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
    <tr>
      <th>138</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Xiaojuan Qian</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>144</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Quan Xu</td>
      <td>Female</td>
      <td>44.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



query()中属于该 Series 的方法均可被正常调用


```python
df.query('Weight > Weight.median()').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Qiang Chu</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Xiaopeng Zhou</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



query中引用带空格的列名需要使用 `` `col name` `` 的方式进行引用。

`or, and, or, in, not in `在query中可用,此处用`is in`会报错


```python
df.query('(Name in ["Qiang Chu","Gaojuan You","Xiaopeng Zhou"]) and'
         '(School not in ["Fudan University"])').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>6</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Qiang Chu</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Xiaopeng Zhou</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>19</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Qiang Chu</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>176</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Xiaopeng Zhou</td>
      <td>Female</td>
      <td>51.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



`in` 也可用Serise中的`isin`方法替代，但需要加上engine='python'


```python
df.query('Name.isin(["Qiang Chu","Gaojuan You","Xiaopeng Zhou"]) and'
         '(School not in ["Fudan University"])', engine='python').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>6</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Qiang Chu</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Xiaopeng Zhou</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>19</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Qiang Chu</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>176</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Xiaopeng Zhou</td>
      <td>Female</td>
      <td>51.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



## 6. 随机抽样

把 DataFrame 的每一行看作一个样本，或把每一列看作一个特征，再把整个 DataFrame 看作总体，想要对样本或特征进行随机抽样就可以用 sample 函数

主要参数为 
>n, 抽样数量
axis, 抽样的方向（0为行、1为列）  
frac, 抽样比例（0.3则为从总体中抽出30%的样本）   
replace, 是否放回, 当 replace = True 则表示有放回抽样  
weights, 抽样权重,Default ‘None’ results in equal probability weighting


```python
df_sample = pd.DataFrame({'id': list('abcde'),'value': [1, 2, 3, 4, 90]})
df_sample
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>d</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>



# 二、多级索引

## 1. 多级索引及其表的结构

构造一张表


```python
np.random.seed(0)  #固定随机种子，使每次生产的随机数一致
multi_index = pd.MultiIndex.from_product([list('ABCD'),
                                          df.Gender.unique()], names=('School', 'Gender'))

multi_column = pd.MultiIndex.from_product([['Height', 'Weight'],
                                           df.Grade.unique()], names=('Indicator', 'Grade'))

df_multi = pd.DataFrame(np.c_[(np.random.randn(8,4)*5 + 163).tolist(),
                              (np.random.randn(8,4)*5 + 65).tolist()],
                        index = multi_index,
                        columns = multi_column).round(1)

df_multi
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Indicator</th>
      <th colspan="4" halign="left">Height</th>
      <th colspan="4" halign="left">Weight</th>
    </tr>
    <tr>
      <th></th>
      <th>Grade</th>
      <th>Freshman</th>
      <th>Senior</th>
      <th>Sophomore</th>
      <th>Junior</th>
      <th>Freshman</th>
      <th>Senior</th>
      <th>Sophomore</th>
      <th>Junior</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Gender</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>Female</th>
      <td>171.8</td>
      <td>165.0</td>
      <td>167.9</td>
      <td>174.2</td>
      <td>60.6</td>
      <td>55.1</td>
      <td>63.3</td>
      <td>65.8</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>172.3</td>
      <td>158.1</td>
      <td>167.8</td>
      <td>162.2</td>
      <td>71.2</td>
      <td>71.0</td>
      <td>63.1</td>
      <td>63.5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">B</th>
      <th>Female</th>
      <td>162.5</td>
      <td>165.1</td>
      <td>163.7</td>
      <td>170.3</td>
      <td>59.8</td>
      <td>57.9</td>
      <td>56.5</td>
      <td>74.8</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>166.8</td>
      <td>163.6</td>
      <td>165.2</td>
      <td>164.7</td>
      <td>62.5</td>
      <td>62.8</td>
      <td>58.7</td>
      <td>68.9</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">C</th>
      <th>Female</th>
      <td>170.5</td>
      <td>162.0</td>
      <td>164.6</td>
      <td>158.7</td>
      <td>56.9</td>
      <td>63.9</td>
      <td>60.5</td>
      <td>66.9</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>150.2</td>
      <td>166.3</td>
      <td>167.3</td>
      <td>159.3</td>
      <td>62.4</td>
      <td>59.1</td>
      <td>64.9</td>
      <td>67.1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">D</th>
      <th>Female</th>
      <td>174.3</td>
      <td>155.7</td>
      <td>163.2</td>
      <td>162.1</td>
      <td>65.3</td>
      <td>66.5</td>
      <td>61.8</td>
      <td>63.2</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>170.7</td>
      <td>170.3</td>
      <td>163.8</td>
      <td>164.9</td>
      <td>61.6</td>
      <td>63.2</td>
      <td>60.9</td>
      <td>56.4</td>
    </tr>
  </tbody>
</table>
</div>



下图通过颜色区分，标记了 DataFrame 的结构。与单层索引的表一样，具备元素值、行索引和列索引三个部分。其中，这里的行索引和列索引都是 MultiIndex 类型，只不过 索引中的一个元素是元组 而不是单层索引中的标量。例如，行索引的第四个元素为 ("B", "Male") ，列索引的第二个元素为 ("Height", "Senior") ，这里需要注意，外层连续出现相同的值时，第一次之后出现的会被隐藏显示，使结果的可读性增强。

![img1](./multi_index.png)

与单层索引类似， MultiIndex 也具有名字属性，图中的 School 和 Gender 分别对应了表的第一层和第二层行索引的名字， Indicator 和 Grade 分别对应了第一层和第二层列索引的名字。

索引的名字和值属性分别可以通过 names 和 values 获得：


```python
df_multi.index.names
```




    FrozenList(['School', 'Gender'])




```python
df_multi.columns.names
```




    FrozenList(['Indicator', 'Grade'])




```python
df_multi.index.values 
```




    array([('A', 'Female'), ('A', 'Male'), ('B', 'Female'), ('B', 'Male'),
           ('C', 'Female'), ('C', 'Male'), ('D', 'Female'), ('D', 'Male')],
          dtype=object)




```python
df_multi.columns.values
```




    array([('Height', 'Freshman'), ('Height', 'Senior'),
           ('Height', 'Sophomore'), ('Height', 'Junior'),
           ('Weight', 'Freshman'), ('Weight', 'Senior'),
           ('Weight', 'Sophomore'), ('Weight', 'Junior')], dtype=object)



可通过 get_level_values得到某一层的索引：


```python
 df_multi.index.get_level_values(1)
```




    Index(['Female', 'Male', 'Female', 'Male', 'Female', 'Male', 'Female', 'Male'], dtype='object', name='Gender')



## 2. 多级索引中的loc索引器

将原表学校和年级设为索引，此时的行为多级索引，列为单级索引


```python
df_multi = df.set_index(['School', 'Grade'])
df_multi.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Freshman</th>
      <td>Gaopeng Yang</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <th>Freshman</th>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Senior</th>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Fudan University</th>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



默认状态的列索引不含名字，因此对应于刚刚图中 Indicator 和 Grade 的索引名位置是空缺的

由于多级索引中的单个元素以元组为单位，因此之前在第一节介绍的 loc 和 iloc 方法完全可以照搬，只需把标量的位置替换成对应的元组。

当传入元组列表或单个元组或返回前二者的函数时，需要先进行索引排序以避免性能警告：


```python
df_sorted = df_multi.sort_index()
df_sorted.loc[('Fudan University', 'Junior')].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Junior</th>
      <td>Yanli You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Yanjuan Lv</td>
      <td>Female</td>
      <td>49.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoqiang Zhou</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_sorted.loc[[('Fudan University', 'Senior'),
               ('Shanghai Jiao Tong University', 'Freshman')]].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Senior</th>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Feng Zhou</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Gaomei Lv</td>
      <td>Female</td>
      <td>34.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chunli Lv</td>
      <td>Female</td>
      <td>56.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_sorted.loc[[('Fudan University', 'Senior'),
               ('Shanghai Jiao Tong University', 'Freshman')]].tail()    
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Shanghai Jiao Tong University</th>
      <th>Freshman</th>
      <td>Chunmei Shi</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Freshman</th>
      <td>Xiaomei Yang</td>
      <td>Female</td>
      <td>49.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Freshman</th>
      <td>Xiaofeng Qian</td>
      <td>Female</td>
      <td>49.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Freshman</th>
      <td>Changmei Lv</td>
      <td>Male</td>
      <td>75.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Freshman</th>
      <td>Qiang Feng</td>
      <td>Male</td>
      <td>80.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



也可使用布尔列表进行筛选


```python
df_sorted.loc[df_sorted.Weight > 70].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Freshman</th>
      <td>Feng Wang</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Qian</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



使用函数


```python
df_sorted.loc[lambda x:('Fudan University','Junior')].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Junior</th>
      <td>Yanli You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Yanjuan Lv</td>
      <td>Female</td>
      <td>49.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoqiang Zhou</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



当使用切片时需要注意，在单级别索引中只要切片端点元素是唯一的，那么就可以进行切片，但在多级索引中，<font color=red>无论元组在索引中是否重复出现，都必须经过排序才能使用切片，否则报错</font>：


```python
df_sorted.loc[('Fudan University', 'Senior'):].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Senior</th>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Feng Zhou</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Gaomei Lv</td>
      <td>Female</td>
      <td>34.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chunli Lv</td>
      <td>Female</td>
      <td>56.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_unique = df.drop_duplicates(subset=['School','Grade']
                               ).set_index(['School', 'Grade'])

df_unique.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Freshman</th>
      <td>Gaopeng Yang</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <th>Freshman</th>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Senior</th>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Fudan University</th>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Tsinghua University</th>
      <th>Freshman</th>
      <td>Xiaoli Qian</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_unique.sort_index().loc[('Fudan University', 'Senior'):].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fudan University</th>
      <th>Senior</th>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">Peking University</th>
      <th>Freshman</th>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Juan Xu</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Changli Lv</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



【延伸】在多级索引中的元组有一种特殊的用法，可以对多层的元素进行交叉组合后索引，但同时需要指定 loc 的列，全选则用 : 表示。其中，每一层需要选中的元素用列表存放，传入 loc 的形式为 [(level_0_list, level_1_list), cols] 。例如，想要得到所有北大和复旦的大二大三学生，可以如下写出：


```python
res = df_multi.loc[(['Peking University', 'Fudan University'],
                    ['Sophomore', 'Junior']), :]

res.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fudan University</th>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Peking University</th>
      <th>Junior</th>
      <td>Juan Xu</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changjuan You</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Fudan University</th>
      <th>Junior</th>
      <td>Yanli You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



下面的语句和上面类似，但仍然传入的是元素（这里为元组）的列表，它们的意义是不同的，表示的是选出北大的大三学生和复旦的大二学生：


```python
res = df_multi.loc[[('Peking University', 'Junior'),
                    ('Fudan University', 'Sophomore')]]

print(res.head())
print(res.tail())
```

                                       Name  Gender  Weight Transfer
    School            Grade                                         
    Peking University Junior        Juan Xu  Female     NaN        N
                      Junior  Changjuan You  Female    47.0        N
                      Junior       Gaoli Xu  Female    48.0        N
                      Junior   Gaoquan Zhou    Male    70.0        N
                      Junior      Qiang You  Female    56.0        N
                                           Name  Gender  Weight Transfer
    School           Grade                                              
    Fudan University Sophomore           Mei Xu    Male    79.0        N
                     Sophomore    Chengqiang Lv  Female    53.0        N
                     Sophomore     Xiaojuan Chu    Male    68.0        N
                     Sophomore  Changqiang Qian    Male    64.0        N
                     Sophomore           Li Sun  Female    57.0        N
    

## 3. IndexSlice对象

前面介绍的方法，即使在索引不重复的时候，也只能对元组整体进行切片，而不能对每层进行切片，也不允许将切片和布尔列表混合使用，引入 `IndexSlice` 对象就能解决这个问题。 `Slice` 对象一共有两种形式，第一种为` loc[idx[*,*]] `型，第二种为   ` loc[idx[*,*],idx[*,*]] `型，下面将进行介绍。为了方便演示，下面构造一个 索引不重复的 DataFrame ：


```python
np.random.seed(0)
L1,L2 = ['A','B','C'],['a','b','c']
mul_index1 = pd.MultiIndex.from_product([L1,L2],names=('Upper', 'Lower'))
L3,L4 = ['D','E','F'],['d','e','f']
mul_index2 = pd.MultiIndex.from_product([L3,L4],names=('Big', 'Small'))

df_ex = pd.DataFrame(np.random.randint(-9,10,(9,9)),
                     index=mul_index1,
                     columns=mul_index2)

df_ex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="3" halign="left">D</th>
      <th colspan="3" halign="left">E</th>
      <th colspan="3" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">A</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
      <td>-4</td>
      <td>4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">B</th>
      <th>a</th>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
    </tr>
    <tr>
      <th>c</th>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">C</th>
      <th>a</th>
      <td>-6</td>
      <td>-3</td>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1</td>
      <td>2</td>
      <td>-5</td>
      <td>-3</td>
      <td>-5</td>
      <td>6</td>
      <td>-6</td>
      <td>3</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>5</td>
      <td>6</td>
      <td>-6</td>
      <td>6</td>
      <td>4</td>
      <td>7</td>
      <td>8</td>
      <td>-4</td>
    </tr>
  </tbody>
</table>
</div>



对silce 对象进行定义


```python
idx = pd.IndexSlice
```

### 【a】 `loc[idx[*,*]] `型

这种情况并不能进行多层分别切片，前一个 * 表示行的选择，后一个 * 表示列的选择，与单纯的 loc 类似


```python
df_ex.loc[idx[('B','c'):, ('D','f'):]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th>D</th>
      <th colspan="3" halign="left">E</th>
      <th colspan="3" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>B</th>
      <th>c</th>
      <td>-5</td>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">C</th>
      <th>a</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-5</td>
      <td>-3</td>
      <td>-5</td>
      <td>6</td>
      <td>-6</td>
      <td>3</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>6</td>
      <td>-6</td>
      <td>6</td>
      <td>4</td>
      <td>7</td>
      <td>8</td>
      <td>-4</td>
    </tr>
  </tbody>
</table>
</div>



布尔序列


```python
df_ex.loc[idx[:'A', lambda x:x.mean()>0]] # 列均值大于0
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="2" halign="left">D</th>
      <th>F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>d</th>
      <th>e</th>
      <th>e</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">A</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-3</td>
      <td>3</td>
      <td>-4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>0</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



### 【b】 `loc[idx[*,*],idx[*,*]]` 型
分层进行切片，前一个 idx 指代的是行索引，后一个是列索引。


```python
df_ex.loc[idx[:'A', 'b':], idx['E':, 'e':]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="2" halign="left">E</th>
      <th colspan="2" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>e</th>
      <th>f</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>b</th>
      <td>-2</td>
      <td>5</td>
      <td>-4</td>
      <td>4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>6</td>
      <td>6</td>
      <td>9</td>
      <td>-6</td>
    </tr>
  </tbody>
</table>
</div>



## 4. 多级索引的构造

前面提到了多级索引表的结构和切片，那么除了使用 set_index 之外，如何自己构造多级索引呢？常用的有 ` from_tuples, from_arrays, from_product ` 三种方法，它们都是 ` pd.MultiIndex ` 对象下的函数。

`from_tuples `指根据传入由元组组成的列表进行构造：


```python
my_tuple = [('a','cat'),('a','dog'),('b','cat'),('b','dog')]

pd.MultiIndex.from_tuples(my_tuple, names=['First','Second'])
```




    MultiIndex(levels=[['a', 'b'], ['cat', 'dog']],
               labels=[[0, 0, 1, 1], [0, 1, 0, 1]],
               names=['First', 'Second'])



`from_arrays `指根据传入列表中，对应层的列表进行构造：


```python
my_array = [list('aabb'), ['cat', 'dog']*2]
pd.MultiIndex.from_arrays(my_array, names=['First','Second'])
```




    MultiIndex(levels=[['a', 'b'], ['cat', 'dog']],
               labels=[[0, 0, 1, 1], [0, 1, 0, 1]],
               names=['First', 'Second'])



` from_product `指根据给定多个列表的笛卡尔积进行构造：


```python
my_list1,my_list2 = ['a','b'],['cat','dog']
pd.MultiIndex.from_product([my_list1,
                            my_list2],
                           names=['First','Second'])
```




    MultiIndex(levels=[['a', 'b'], ['cat', 'dog']],
               labels=[[0, 0, 1, 1], [0, 1, 0, 1]],
               names=['First', 'Second'])



# 三、索引的常用方法

## 1. 索引层的交换和删除



```python
np.random.seed(42)
L1,L2,L3 = ['A','B'],['a','b'],['alpha','beta']
mul_index1 = pd.MultiIndex.from_product([L1,L2,L3],
                                        names=('Upper', 'Lower','Extra'))

L4,L5,L6 = ['A','B'],['a','b'],['cat','dog']
mul_index2 = pd.MultiIndex.from_product([L4,L5,L6],
                                        names=('Big', 'Mid', 'Small'))

df_ex = pd.DataFrame(np.random.randint(-9,10,(8,8)),
                     index=mul_index1,
                     columns=mul_index2)

df_ex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">A</th>
      <th colspan="4" halign="left">B</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Mid</th>
      <th colspan="2" halign="left">a</th>
      <th colspan="2" halign="left">b</th>
      <th colspan="2" halign="left">a</th>
      <th colspan="2" halign="left">b</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>-3</td>
      <td>5</td>
      <td>1</td>
      <td>-2</td>
      <td>-3</td>
      <td>9</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-6</td>
      <td>-2</td>
      <td>-7</td>
      <td>-8</td>
      <td>2</td>
      <td>-4</td>
      <td>-8</td>
      <td>-9</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>2</td>
      <td>2</td>
      <td>7</td>
      <td>0</td>
      <td>6</td>
      <td>5</td>
      <td>5</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>2</td>
      <td>-7</td>
      <td>-5</td>
      <td>9</td>
      <td>-3</td>
      <td>-1</td>
      <td>-3</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">B</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>-6</td>
      <td>4</td>
      <td>8</td>
      <td>-1</td>
      <td>-8</td>
      <td>5</td>
      <td>-3</td>
      <td>2</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-2</td>
      <td>5</td>
      <td>-7</td>
      <td>4</td>
      <td>7</td>
      <td>-6</td>
      <td>8</td>
      <td>-2</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-6</td>
      <td>-8</td>
      <td>-4</td>
      <td>0</td>
      <td>-6</td>
      <td>8</td>
      <td>2</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>0</td>
      <td>-6</td>
      <td>4</td>
      <td>6</td>
      <td>5</td>
      <td>-2</td>
      <td>4</td>
      <td>-2</td>
    </tr>
  </tbody>
</table>
</div>



索引层的交换由` swaplevel `和` reorder_levels `完成，前者只能交换两个层，而后者可以交换任意层，两者都可以指定交换的是轴是哪一个，即行索引或列索引：

>注：这两种方法都不改变原数据，也无相关参数使其在原数据基础上修改


```python
 df_ex.swaplevel(0,2,axis=1).head() # 列索引的第一层和第三层交换
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Mid</th>
      <th>a</th>
      <th>a</th>
      <th>b</th>
      <th>b</th>
      <th>a</th>
      <th>a</th>
      <th>b</th>
      <th>b</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th>A</th>
      <th>A</th>
      <th>A</th>
      <th>A</th>
      <th>B</th>
      <th>B</th>
      <th>B</th>
      <th>B</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>-3</td>
      <td>5</td>
      <td>1</td>
      <td>-2</td>
      <td>-3</td>
      <td>9</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-6</td>
      <td>-2</td>
      <td>-7</td>
      <td>-8</td>
      <td>2</td>
      <td>-4</td>
      <td>-8</td>
      <td>-9</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>2</td>
      <td>2</td>
      <td>7</td>
      <td>0</td>
      <td>6</td>
      <td>5</td>
      <td>5</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>2</td>
      <td>-7</td>
      <td>-5</td>
      <td>9</td>
      <td>-3</td>
      <td>-1</td>
      <td>-3</td>
      <td>8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>-6</td>
      <td>4</td>
      <td>8</td>
      <td>-1</td>
      <td>-8</td>
      <td>5</td>
      <td>-3</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_ex.reorder_levels([2,0,1],axis=0).head() # 列表数字指代原来索引中的层
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">A</th>
      <th colspan="4" halign="left">B</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Mid</th>
      <th colspan="2" halign="left">a</th>
      <th colspan="2" halign="left">b</th>
      <th colspan="2" halign="left">a</th>
      <th colspan="2" halign="left">b</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Extra</th>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>alpha</th>
      <th>A</th>
      <th>a</th>
      <td>-3</td>
      <td>5</td>
      <td>1</td>
      <td>-2</td>
      <td>-3</td>
      <td>9</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>beta</th>
      <th>A</th>
      <th>a</th>
      <td>-6</td>
      <td>-2</td>
      <td>-7</td>
      <td>-8</td>
      <td>2</td>
      <td>-4</td>
      <td>-8</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>alpha</th>
      <th>A</th>
      <th>b</th>
      <td>2</td>
      <td>2</td>
      <td>7</td>
      <td>0</td>
      <td>6</td>
      <td>5</td>
      <td>5</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <th>A</th>
      <th>b</th>
      <td>2</td>
      <td>-7</td>
      <td>-5</td>
      <td>9</td>
      <td>-3</td>
      <td>-1</td>
      <td>-3</td>
      <td>8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <th>B</th>
      <th>a</th>
      <td>-6</td>
      <td>4</td>
      <td>8</td>
      <td>-1</td>
      <td>-8</td>
      <td>5</td>
      <td>-3</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



若想要删除某一层的索引，可以使用` droplevel `方法：


```python
df_ex.droplevel(0,axis=0)
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-224-2c66d2633d0b> in <module>()
    ----> 1 df_ex.droplevel(1,axis=1)
    

    C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\generic.py in __getattr__(self, name)
       4374             if self._info_axis._can_hold_identifiers_and_holds_name(name):
       4375                 return self[name]
    -> 4376             return object.__getattribute__(self, name)
       4377 
       4378     def __setattr__(self, name, value):
    

    AttributeError: 'DataFrame' object has no attribute 'droplevel'


## 2. 索引属性的修改

通过` rename_axis `可以对索引层的名字进行修改，常用的修改方式是传入字典的映射：


```python
df_ex.rename_axis(index={'Upper':'Changed_row'},
                  columns={'Mid':'Changed_Col'}).head()
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-225-04e162090e6e> in <module>()
          1 df_ex.rename_axis(index={'Upper':'Changed_row'},
    ----> 2                   columns={'Mid':'Changed_Col'}).head()
    

    TypeError: rename_axis() got an unexpected keyword argument 'index'


通过 rename 可以对索引的值进行修改，如果是多级索引需要指定修改的层号 level ：


```python
df_ex.rename(columns={'cat':'not_cat'},
             level=2).head()
```

传入参数也可以是函数，其输入值就是索引元素：


```python
df_ex.rename(index=lambda x:str.upper(x),
             level=2).head()
```

对于整个索引的元素替换，可以利用**迭代器**实现：


```python
new_values = iter(list('abcdefgh'))
df_ex.rename(index=lambda x:next(new_values),
             level=2)
```


```python
df_temp = df_ex.copy()
new_idx = df_temp.index.map(lambda x: (x[0],x[1],str.upper(x[2])))
df_temp.index = new_idx
df_temp.head()
```

关于 map 的另一个使用方法是对多级索引的压缩，这在第四章和第五章的一些操作中是有用的：


```python
df_temp = df_ex.copy()
new_idx = df_temp.index.map(lambda x: (x[0] + '-' + x[1] + '-' + x[2]))
df_temp.index = new_idx
df_temp.head() # 单层索引
```

展开


```python
new_idx = df_temp.index.map(lambda x:tuple(x.split('-')))
df_temp.index = new_idx
df_temp.head() # 三层索引
```

## 3. 索引的设置与重置


```python
df_new = pd.DataFrame({'A':list('aacd'),'B':list('PQRT'),'C':[1,2,3,4]})
df_new
```

索引的设置可以使用` set_index `完成，这里的主要参数是` append `，表示是否来保留原来的索引，直接把新设定的添加到原索引的内层：
>append: True-保留原索引，默认为False,不保留


```python
df_new.set_index('A')
```


```python
df_new.set_index('A', append=True)
```

可以同时指定多个列作为索引：


```python
 df_new.set_index(['A', 'B'])
```

如果想要添加索引的列没有出现在其中，那么可以直接在参数中传入相应的 Series ：


```python
my_index = pd.Series(list('WXYZ'), name='D')
df_new = df_new.set_index(['A', my_index])
df_new
```

reset_index 是 set_index 的逆函数，其主要参数是 drop ，表示是否要把去掉的索引层丢弃，而不是添加到列中：


```python

```
